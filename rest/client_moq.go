// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package rest

import (
	"context"
	"golang.org/x/time/rate"
	"net/http"
	"sync"
)

// Ensure, that ClientMock does implement Client.
// If this is not the case, regenerate this file with moq.
var _ Client = &ClientMock{}

// ClientMock is a mock implementation of Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked Client
//		mockedClient := &ClientMock{
//			ClientFunc: func() *http.Client {
//				panic("mock out the Client method")
//			},
//			CloseFunc: func(ctx context.Context)  {
//				panic("mock out the Close method")
//			},
//			DoFunc: func(ctx context.Context, endpoint *Endpoint, payload any, response any, opts ...RequestOption) (int, error) {
//				panic("mock out the Do method")
//			},
//			RateLimiterFunc: func() *rate.Limiter {
//				panic("mock out the RateLimiter method")
//			},
//		}
//
//		// use mockedClient in code that requires Client
//		// and then make assertions.
//
//	}
type ClientMock struct {
	// ClientFunc mocks the Client method.
	ClientFunc func() *http.Client

	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context)

	// DoFunc mocks the Do method.
	DoFunc func(ctx context.Context, endpoint *Endpoint, payload any, response any, opts ...RequestOption) (int, error)

	// RateLimiterFunc mocks the RateLimiter method.
	RateLimiterFunc func() *rate.Limiter

	// calls tracks calls to the methods.
	calls struct {
		// Client holds details about calls to the Client method.
		Client []struct {
		}
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Do holds details about calls to the Do method.
		Do []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Endpoint is the endpoint argument value.
			Endpoint *Endpoint
			// Payload is the payload argument value.
			Payload any
			// Response is the response argument value.
			Response any
			// Opts is the opts argument value.
			Opts []RequestOption
		}
		// RateLimiter holds details about calls to the RateLimiter method.
		RateLimiter []struct {
		}
	}
	lockClient      sync.RWMutex
	lockClose       sync.RWMutex
	lockDo          sync.RWMutex
	lockRateLimiter sync.RWMutex
}

// Client calls ClientFunc.
func (mock *ClientMock) Client() *http.Client {
	if mock.ClientFunc == nil {
		panic("ClientMock.ClientFunc: method is nil but Client.Client was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClient.Lock()
	mock.calls.Client = append(mock.calls.Client, callInfo)
	mock.lockClient.Unlock()
	return mock.ClientFunc()
}

// ClientCalls gets all the calls that were made to Client.
// Check the length with:
//
//	len(mockedClient.ClientCalls())
func (mock *ClientMock) ClientCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClient.RLock()
	calls = mock.calls.Client
	mock.lockClient.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *ClientMock) Close(ctx context.Context) {
	if mock.CloseFunc == nil {
		panic("ClientMock.CloseFunc: method is nil but Client.Close was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedClient.CloseCalls())
func (mock *ClientMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Do calls DoFunc.
func (mock *ClientMock) Do(ctx context.Context, endpoint *Endpoint, payload any, response any, opts ...RequestOption) (int, error) {
	if mock.DoFunc == nil {
		panic("ClientMock.DoFunc: method is nil but Client.Do was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Endpoint *Endpoint
		Payload  any
		Response any
		Opts     []RequestOption
	}{
		Ctx:      ctx,
		Endpoint: endpoint,
		Payload:  payload,
		Response: response,
		Opts:     opts,
	}
	mock.lockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	mock.lockDo.Unlock()
	return mock.DoFunc(ctx, endpoint, payload, response, opts...)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//
//	len(mockedClient.DoCalls())
func (mock *ClientMock) DoCalls() []struct {
	Ctx      context.Context
	Endpoint *Endpoint
	Payload  any
	Response any
	Opts     []RequestOption
} {
	var calls []struct {
		Ctx      context.Context
		Endpoint *Endpoint
		Payload  any
		Response any
		Opts     []RequestOption
	}
	mock.lockDo.RLock()
	calls = mock.calls.Do
	mock.lockDo.RUnlock()
	return calls
}

// RateLimiter calls RateLimiterFunc.
func (mock *ClientMock) RateLimiter() *rate.Limiter {
	if mock.RateLimiterFunc == nil {
		panic("ClientMock.RateLimiterFunc: method is nil but Client.RateLimiter was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRateLimiter.Lock()
	mock.calls.RateLimiter = append(mock.calls.RateLimiter, callInfo)
	mock.lockRateLimiter.Unlock()
	return mock.RateLimiterFunc()
}

// RateLimiterCalls gets all the calls that were made to RateLimiter.
// Check the length with:
//
//	len(mockedClient.RateLimiterCalls())
func (mock *ClientMock) RateLimiterCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRateLimiter.RLock()
	calls = mock.calls.RateLimiter
	mock.lockRateLimiter.RUnlock()
	return calls
}
